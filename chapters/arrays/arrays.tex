%================================================
% CAPÍTULO ARRAYS
%================================================

\chapterimage{chapter_pointers.jpg} % Chapter heading image

\chapter{Arrays}
Quem nunca precisou organizar dados semelhantes num único local? Eu sim, você não? Então quando você, por exemplo, escreve um texto, o que acha que está fazendo? \say{\textit{Organizando ideias?}}. Sim, também! Contudo, o que você está organizando materialmente são caracteres. Vejamos:

\begin {center}
  \begin{bytefield}[bitwidth=1em]{17}
    \bitbox{17}{Autor presunçoso!}\\
    \bitbox{1}{A} \bitbox{1}{u} \bitbox{1}{t} \bitbox{1}{o} \bitbox{1}{r} \bitbox{1}{ }
    \bitbox{1}{p} \bitbox{1}{r} \bitbox{1}{e} \bitbox{1}{s} \bitbox{1}{u} \bitbox{1}{n}
    \bitbox{1}{ç} \bitbox{1}{o} \bitbox{1}{s} \bitbox{1}{o} \bitbox{1}{!}
  \end{bytefield}
\end{center}

A frase \textit{Autor presunçoso!} é a organização de dezessete caracteres um atrás do outro. Isso mesmo, dezessete, pois o espaço também é um dado. Nunca se esqueça que, quando tratamos dados, até um \say{0} ocupa espaço na memória do computador.

Segue outra organização de dados. Desta vez de inteiros que serão o resultado do próximo sorteio da mega-sena.

\begin{center}
  \begin{bytefield}[endianness=little,bitwidth=6em]{6}
    \bitbox{1}{9} \bitbox{1}{20} \bitbox{1}{11}
    \bitbox{1}{7} \bitbox{1}{43} \bitbox{1}{31}\\
    % \bitheader{0-5}
  \end{bytefield}
\end{center}

Ambos são exemplos de \textbf{arrays} que, em C, são tipos de dados de alocação contíngua derivados dos tipos simples. Em outras palavras, são estruturas de dados homogêneas, compostas de elementos de mesmo tipo, e posicionados em sequência na memória. Arrays também são conhecidos como \textit{vetores}, quando a sequência dos dados é unidimensional (linear), e como \textit{matrizes}, quando essa sequência se dá multimensionalmente. Divagaremos a respeito mais a frente.

\begin{remark}
Em algumas fontes esparsas de idioma português, você, leitor, encontrará referências a arrays como sendo \textit{\textbf{arranjos}}. Ressaltamos que um array, numa tradução mais fiel, é um \textit{\textbf{conjunto}} de dados. Já um arranjo:
  \begin{figure}[!htp]
    \centering
    \includegraphics[scale=0.7, keepaspectratio=true]{arrays_arrange.jpg}
    \caption{Array não é Arranjo}
    \label{fig:arrays_arrange}
  \end{figure}
\end{remark}


\section{Trabalhando com Arrays}
\subsection{Definindo Arrays}

Ao definirmos um array é necessário determinarmos o respectivo tamanho.

\begin{ccode}
  int i[6];
  char c[3];
\end{ccode}

O uso do operador de índice [] é que informa ao compilador que as variáveis \textbf{i} e \textbf{c} são do tipo array. Já o número entre os colchetes define a quantidade de elementos a serem alocados para o array em questão. No código acima, \textbf{i} é definido como um array de int com seis elementos e \textbf{c} um array de char com três elementos.

\begin{center}
  \begin{bytefield}[endianness=little,bitwidth=6em]{6}
    i[6]\\
    \bitbox{1}{-57} \bitbox{1}{3} \bitbox{1}{791431480}
    \bitbox{1}{0} \bitbox{1}{32767} \bitbox{1}{0}\\
    \bitheader{0-5}\\
  \end{bytefield}
  \begin{bytefield}[endianness=little,bitwidth=2em]{3}
    c[3]\\
    \bitbox{1}{0} \bitbox{1}{-10} \bitbox{1}{49}\\
    \bitheader{0-2}
  \end{bytefield}
\end{center}

Uma boa prática de programação é inicializar os arrays, assim como os tipos simples, pois, tanto em i[] quanto em c[], vemos claramente que os elementos contêm valores aleatórios. Isso se dá pelo lixo encontrado na área da memória usada por esses recém-definidos arrays num escopo local.


\subsection{Declarando Arrays}
Faz bem relembrarmos que declarar não é o mesmo que inicializar, portanto, ao contrário do que se pensa comumente, arrays podem normalmente ser declarados. Para tanto, basta fazermos uso do modificador \textit{extern} já visto no item 3.3.

Forçando a quantidade de elementos.

\textit{array.h}\\
\begin{ccode}
extern int ext1[32];
\end{ccode}

Ou não, deixando para a definição.

\textit{main.c}\\
\begin{ccode}
#include ``array.h''
...
extern int ext2[];
...
\end{ccode}


\subsection{Inicializando Arrays}
Recordar é viver, portanto: \say{inicializar é atribuir valor no ato da declaração e/ou declaração}. No caso de arrays podemos inicializá-los de várias formas, vejamos.

Inicializando todos os elementos um a um.

\begin{ccode}
  int array[3] = {1, 5, 10};
\end{ccode}

Inicializando todos os elementos com zero.

\begin{ccode}
  int array[3] = {0};
\end{ccode}

Inicializando todos os elementos com zero, também.

\begin{ccode}
  int array[3] = {};
\end{ccode}

Inicializando o primeiro elemento com 5 e os demais com zero.

\begin{ccode}
  int array[3] = {5};
\end{ccode}

Quando um array é definido num escopo global ou com a classe de armazenamento \textit{static} e não há inicialização explícita, de acordo com o \textit{C Standard}, todos os elementos são inicializados com zero.

Inicializando todos os elementos com zero por definiçao estática.

\begin{ccode}
  static int array[6];
\end{ccode}

Inicializando por escopo global.

\begin{ccode}
int array[6];    /* Os elementos de array são inicializados
                    com zero, automaticamente */

int main(void)
{
  return 0;
}
\end{ccode}

\subsection{Atribuindo Valores em Arrays}

\begin{ccode}
  int att[2];
  att[0] = 10;
  att[0] = 20;
\end{ccode}

\subsection{Acessando Arrays}

\section{Array de Caracteres}

\section{Arrays na Vida Real?!}
\subsection{Imprimir Elementos}
\subsection{Somar Elementos}
\subsection{Inverter o Array}
\subsection{Ordenar o Array}

\section{Arrays como Parâmetros}

\section{Arrays Multidimensionais (Matrizes)}


%------------------------------------------------
